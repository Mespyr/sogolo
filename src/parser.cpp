#include "../include/parser.hpp"

namespace Parser {
    // Functions
    bool is_number(const std::string& s) {
        std::string::const_iterator it = s.begin();
        while (it != s.end() && std::isdigit(*it)) 
            ++it;
        return !s.empty() && it == s.end();
    }

    AtomType generate_atom_type(std::string str) {
        if (str.front() == '`') {
            return OBJ_STRING;
        }
        if (str.front() == '\'') {
            return OBJ_STRING;
        }
        if (is_number(str)) {
            return OBJ_NUMBER;
        }
        return AST_SYMBOL;
    }

    std::string get_type(AtomType tp) {
        if (tp == OBJ_STRING) {
            return "STRING";
        }
        else if (tp == OBJ_CHAR) {
            return "CHAR";
        }
        else if (tp == OBJ_NUMBER) {
            return "NUMBER";
        }
        return "SYMBOL";
    }

    // Errors
    std::string EOF_ERROR::error() {
        std::string error_msg = "EOF Error on line " + std::to_string(token.line_number) + ".\n";
        error_msg += "  " + token.line + "\n";
        error_msg += msg + "\n";
        return error_msg;
    }

    std::string PARSING_ERROR::error() {
        std::string error_msg = "Parsing Error on line " + std::to_string(token.line_number) + ".\n";
        error_msg += token.line + "\n";
        error_msg += msg + "\n";
        return error_msg;
    }

    std::string Parser::get_error() {
        if (ErrorType == EOF_)
            return eof_error.error();
        else
            return parsing_error.error();
    }
    
    
    // build a Block node from vector generated by parser.
    Node Parser::build_Block_from_vector(std::vector<Node> vec, std::string line, unsigned int line_number) {
        Node node{AST_BLOCK};
        node.line = line;
        node.line_number = line_number;

        Node curline{AST_LINE};
        for (int i = 0; i < vec.size(); i++) {
            Node curnode = vec.at(i);
            if (curnode.type == AST_ATOM) {
                if (curnode.value == ";") {
                    curline.line = curnode.line;
                    curline.line_number = curnode.line_number;

                    node.nodes.push_back(curline);
                    curline.nodes.clear();
                    continue;
                }
            }
            
            else if (curnode.type == AST_BLOCK) {
                curline.line = curnode.line;
                curline.line_number = curnode.line_number;

                curline.nodes.push_back(curnode);
                node.nodes.push_back(curline);
                curline.nodes.clear();
                continue;
            }
            
            else if (curnode.type == AST_ARGMAP) {
                if (curline.nodes.size() > 0) {
                    Node cn = curline.nodes.back();
                    curline.nodes.pop_back();
                    Node new_expr_node{AST_FUNCTION_CALL};
                    new_expr_node.nodes.push_back(cn);
                    new_expr_node.nodes.push_back(curnode);
                    curline.nodes.push_back(new_expr_node);
                    continue;
                }
                else 
                    return node;
            }
            
            curline.nodes.push_back(curnode);
        }
        return node;
    }

    // build an ArgMap node from vector generated by parser.
    Node Parser::build_ArgMap_from_vector(std::vector<Node> vec, std::string line, unsigned int line_number) {
        Node node{AST_ARGMAP};
        Node cn;
        
        // States
        bool left_over = false;
        bool set_cn = false;

        for (int i = 0; i < vec.size(); i++) {
            Node curnode = vec.at(i);
            if (curnode.type == AST_ATOM) {
                if (curnode.value == ",") {
                    if (set_cn) {
                        node.nodes.push_back(cn);
                        left_over = false;
                        set_cn = false;
                        continue;
                    }
                    else
                        return cn;
                }
            }
            else if (curnode.type == AST_ARGMAP) {
                if (set_cn) {
                    Node new_expr_node{AST_FUNCTION_CALL};
                    new_expr_node.nodes.push_back(cn);
                    new_expr_node.nodes.push_back(curnode);
                    cn = new_expr_node;
                    continue;
                }
                else
                    return cn;
            }
            left_over = true;
            cn = curnode;
            set_cn = true;
        }
        if (left_over)
            node.nodes.push_back(cn);
        return node;
    }

    // build a Block node from vector generated by parser.
    Node Parser::build_Expression_from_vector(std::vector<Node> vec, std::string line, unsigned int line_number) {
        Node node{AST_EXPRESSION};
        Node cn;
        for (int i = 0; i < vec.size(); i++) {
            Node curnode = vec.at(i);
            if (curnode.type == AST_ARGMAP) {
                if (node.nodes.size() > 0) {
                    node.nodes.pop_back();
                    Node new_expr_node{AST_FUNCTION_CALL};
                    new_expr_node.nodes.push_back(cn);
                    new_expr_node.nodes.push_back(curnode);
                    curnode = new_expr_node;
                }
                else
                    return cn;
            }
            node.nodes.push_back(curnode);
            cn = curnode;
        }
        return node;
    }

    // Get next node in TokenStream and parse it
    Node Parser::parse_next_node() {
        Token::Token token = stream.next();

        if (token.value == "(") {
            std::vector<Node> node;

            unsigned int line_number = token.line_number;
            std::string line = token.line;

            token = stream.peek();
            while (token.value != ")") {
                node.push_back(parse_next_node());
                if (error_found)
                    return Node{AST_EXPRESSION};
                if (stream.eof) {
                    error_found = true;
                    ErrorType = EOF_;
                    eof_error = EOF_ERROR{"Unexpected EOF while parsing expression.", token};
                    return Node{AST_EXPRESSION};
                }
                token = stream.peek();
            }
            stream.next();
            return build_Expression_from_vector(node, line, line_number);
        }

        else if (token.value == "{") {
            std::vector<Node> node;

            unsigned int line_number = token.line_number;
            std::string line = token.line;

            token = stream.peek();
            while (token.value != "}") {
                node.push_back(parse_next_node());
                if (error_found)
                    return Node{AST_BLOCK};
                if (stream.eof) {
                    error_found = true;
                    ErrorType = EOF_;
                    eof_error = EOF_ERROR{"Unexpected EOF while parsing code.", token};
                    return Node{AST_BLOCK};
                }
                token = stream.peek();
            }
            stream.next();
            return build_Block_from_vector(node, line, line_number);
        }

        else if (token.value == "[") {
            std::vector<Node> node;

            unsigned int line_number = token.line_number;
            std::string line = token.line;

            token = stream.peek();

            while (token.value != "]") {
                node.push_back(parse_next_node());
                if (error_found)
                    return Node{AST_ARGMAP};
                if (stream.eof) {
                    error_found = true;
                    ErrorType = EOF_;
                    eof_error = EOF_ERROR{"Unexpected EOF while parsing arguments.", token};
                    return Node{AST_ARGMAP};
                }
                token = stream.peek();
            }
            stream.next();
            return build_ArgMap_from_vector(node, line, line_number);
        }

        else if (token.value == ")" || token.value == "]" || token.value == "}") {
            error_found = true;
            parsing_error = PARSING_ERROR{"Unexpected '" + token.value + "' token found while parsing.", token};
            return Node{AST_ATOM};
        }

        Node node{AST_ATOM};
        node.line = token.line;
        node.line_number = token.line_number;
        node.value = token.value;
        node.atom_type = generate_atom_type(token.value);
        return node;
    }

    // Parse all nodes
    void Parser::Parser::parse() {
        std::vector<Node> non_sorted_ast;
        if (stream.stream.size() == 0)
            return;
        while (!stream.eof) {
            Node node = parse_next_node();
            if (error_found)
                break;
            non_sorted_ast.push_back(node);
        }
        ast = build_Block_from_vector(non_sorted_ast, "", 1);
    }


    // Debugging
    void Parser::debug_print_vector(Node node, std::string indent) {
        for (int i = 0; i < node.nodes.size(); i++)
            debug_print(node.nodes.at(i), indent+"    ");
    }


    void Parser::debug_print(Node node, std::string indent) {
        if (node.type == AST_BLOCK) {
            std::cout << indent << "<block>" << std::endl;
            debug_print_vector(node, indent);
            std::cout << indent << "</block>" << std::endl;
        }
        else if (node.type == AST_EXPRESSION) {
            std::cout << indent << "<expression>" << std::endl;
            debug_print_vector(node, indent);
            std::cout << indent << "</expression>" << std::endl;
        }
        else if (node.type == AST_ARGMAP) {
            std::cout << indent << "<argument map>" << std::endl;
            debug_print_vector(node, indent);
            std::cout << indent << "</argument map>" << std::endl;
        }
        else if (node.type == AST_FUNCTION_CALL) {
            std::cout << indent << "<function>" << std::endl;
            debug_print_vector(node, indent);
            std::cout << indent << "</function>" << std::endl;
        }
        else if (node.type == AST_LINE) {
            std::cout << indent << "<line>" << std::endl;
            debug_print_vector(node, indent);
            std::cout << indent << "</line>" << std::endl;
        }
        else {
            std::cout << indent << "<atom>" << std::endl;
            std::cout << indent + "    " << "Value = '" << node.value << "'," << std::endl;
            std::cout << indent + "    " << "Line Number = " << node.line_number << "," << std::endl;
            std::cout << indent + "    " << "Line Contents = '" << node.line << "'," << std::endl;
            std::cout << indent + "    " << "Type = " << get_type(node.atom_type) << std::endl;
            std::cout << indent << "</atom>" << std::endl;
        }
    }
} // namespace Parser