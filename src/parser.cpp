#include "../include/parser.hpp"

// Errors ###########################################################
std::string Parser::EOF_ERROR::error()
{
    std::string error_msg = "EOF Error on line " + std::to_string(token.line_number) + ".\n";
    error_msg += token.line + "\n";
    error_msg += msg + "\n";
    return error_msg;
}

std::string Parser::PARSING_ERROR::error()
{
    std::string error_msg = "Parsing Error on line " + std::to_string(token.line_number) + ".\n";
    error_msg += token.line + "\n";
    error_msg += msg + "\n";
    return error_msg;
}


// Parser ###########################################################


// build a Block node from vector generated by parser.
Parser::Node Parser::Parser::build_Block_from_vector(std::vector<Node> vec)
{
    Node node{BLOCK};
    std::vector<Node> curline;
    for (int i = 0; i < vec.size(); i++)
    {
        Node curnode = vec.at(i);
        if (curnode.type == ATOM)
        {
            if (curnode.atom.token.value == ";")
            {
                node.block.push_back(curline);
                curline.clear();
                continue;
            }
        }
        curline.push_back(curnode);
    }
    return node;
}

// build an ArgMap node from vector generated by parser.
Parser::Node Parser::Parser::build_ArgMap_from_vector(std::vector<Node> vec)
{
    Node node{ARGMAP};
    for (int i = 0; i < vec.size(); i++)
    {
        Node curnode = vec.at(i);
        node.expr.push_back(curnode);
    }
    return node;
}

// build a Block node from vector generated by parser.
Parser::Node Parser::Parser::build_Expression_from_vector(std::vector<Node> vec)
{
    Node node{EXPRESSION};
    for (int i = 0; i < vec.size(); i++)
    {
        Node curnode = vec.at(i);
        node.expr.push_back(curnode);
    }
    return node;
}


Parser::Node Parser::Parser::parse_next_node()
{
    Token::Token token = stream.next();

    if (token.value == "(")
    {
        std::vector<Node> node;
        token = stream.peek();
        while (token.value != ")")
        {
            node.push_back(parse_next_node());
            if (error_found)
            {
                return Node{EXPRESSION};
            }
            if (stream.eof)
            {
                error_found = true;
                ErrorType = EOF_;
                eof_error = EOF_ERROR{"Unexpected EOF while parsing expression.", token};
                return Node{EXPRESSION};
            }
            token = stream.peek();
        }
        stream.next();
        return build_Expression_from_vector(node);
    }

    else if (token.value == "{")
    {
        std::vector<Node> node;
        token = stream.peek();
        while (token.value != "}")
        {
            node.push_back(parse_next_node());
            if (error_found)
            {
                return Node{BLOCK};
            }
            if (stream.eof)
            {
                error_found = true;
                ErrorType = EOF_;
                eof_error = EOF_ERROR{"Unexpected EOF while parsing block of code.", token};
                return Node{BLOCK};
            }
            token = stream.peek();
        }
        stream.next();
        return build_Block_from_vector(node);
    }

    else if (token.value == "[")
    {
        std::vector<Node> node;
        token = stream.peek();
        while (token.value != "]")
        {
            node.push_back(parse_next_node());
            if (error_found)
            {
                return Node{ARGMAP};
            }
            if (stream.eof)
            {
                error_found = true;
                ErrorType = EOF_;
                eof_error = EOF_ERROR{"Unexpected EOF while parsing arguments.", token};
                return Node{ARGMAP};
            }
            token = stream.peek();
        }
        stream.next();
        return build_ArgMap_from_vector(node);
    }

    else if (token.value == ")" || token.value == "]" || token.value == "}")
    {
        error_found = true;
        parsing_error = PARSING_ERROR{"Unexpected '" + token.value + "' token found while parsing.", token};
        return Node{ATOM};
    }

    Node node{ATOM};
    node.atom.token = token;
    return node;
}


void Parser::Parser::parse()
{
    std::vector<Node> non_sorted_ast;
    while (!stream.eof)
    {
        Node node = parse_next_node();
        if (error_found)
        {
            break;
        }
        non_sorted_ast.push_back(node);
    }
    ast = build_Block_from_vector(non_sorted_ast);
}


// Debugging
void Parser::Parser::print_line(std::vector<Node> line, std::string indent)
{
    for (int i = 0; i < line.size(); i++)
    { 
        Node n = line.at(i);
        if (n.type == BLOCK)
        {
            std::cout << indent << "BLOCK:" << std::endl;
            debug_print(n, indent+"    ");
            std::cout << indent << "END BLOCK:" << std::endl;
        }
        
        else if (n.type == ARGMAP)
        {
            std::cout << indent << "ARGUMENT MAP:" << std::endl;
            for (int i = 0; i < n.argmap.size(); i++)
            {
                Node line = n.argmap.at(i);
                if (line.type == ATOM)
                {
                    std::cout << indent + "    " << line.atom.token.repr();
                }
                else
                {
                    std::cerr << "ERROR DISPLAYING AST ON NODE" << std::endl;
                }
            }
            std::cout << indent << "END ARGUMENT MAP:" << std::endl;
        }
        
        else if (n.type == EXPRESSION)
        {
            std::cout << indent << "EXPRESSION:" << std::endl;
            for (int i = 0; i < n.expr.size(); i++)
            {
                Node line = n.expr.at(i);
                if (line.type == ATOM)
                {
                    std::cout << indent + "    " << line.atom.token.repr();
                }
                else
                {
                    std::cerr << "ERROR DISPLAYING AST ON NODE" << std::endl;
                }
            }
            std::cout << indent << "END EXPRESSION:" << std::endl;
        }
        else
        {
            std::cout << indent << n.atom.token.repr() << std::endl;
        }
    }
}


void Parser::Parser::debug_print(Node node, std::string indent)
{
    for (int i = 0; i < node.block.size(); i++)
    {
        std::cout << indent << "LINE:" << std::endl;
        std::vector<Node> line = node.block.at(i);
        print_line(line, indent+"    ");
        std::cout << indent << "END LINE:" << std::endl;
    }
}